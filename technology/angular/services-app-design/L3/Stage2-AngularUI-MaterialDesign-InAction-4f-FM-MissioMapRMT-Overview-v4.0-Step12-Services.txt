
============================================================
Services Modules:
		

==>Step 8:	Core Modules
	==>This app doesn't separate services modules or place services into each feature module's service folders
	==>The core modules serves as some main app (global) service function

	==>App-Function: add app config function:		Assigned to Jerry
	==>App-Function: add app cache function:		Assigned to Raghuram
	==>App-Function: add app retry function:		Assigned to Kesava
	==>App-Function: add app notification function:	Assigned to Sridhar
	==>App-Function: add app level function:		Assigned to Kesava
	
	==>Services: stored as core modules
	
		==>Method 1:	Core Modules
		
		
		==>Method 2:	Services Folders
		
						Global Services:
							==>Use a Service for Parent-Child-Component Communication
							==>Use a Service for Cross-Component Communication
								==>Data transfer services
						Utility Services:
							==>Enable logging service
							==>Enable collection or list/set services
						Fake Auth Service
		
		==>Method 3:	Service Classes aside components within "Feature Modules"
		
		
		==>Method 4:	Utils Classes
		
		
		Services Modules and Class Design:
		
			==>
			
			==>DI:
				==>Some use cases worth the review of the Angular documentation sections: ==>POCs don't need these advanced scenarios
				
				injectors hierarchy systems:
				
				==>1) Element Injector:
					Component level: service providers
					
				==>2) Module Injector:
					null injector
					plaform injector / module injector
					root injector
					==>Root injector => child injectors

				Dependencies Resolution Rules:
					1) Element (DOM elements - including components) Injectors: ==>Search from the component up to its topest ancestor component
						@Optional @Self @SkipSelf @Host
					2) Module Injectors:  ==>Search from the component module up to the top module tree
					
				1) global DI:
					@Injectable({
						provideIn: "root"
					})
				2) providers: ...
				   viewProviders: ...
					==>Usage 1:	There are various kinds of providers: refer to the Angular documentations
					==>Usage 2:	Services can have other services as dependencies and injection into the constructors
					==>Usage 3:	Test components can use providers to inject the test parts
				3) constructor injection
					==>Core
					==>Misc:
						@Inject()
						@Optional()
						
				4) Inject services into services
				
			==>
		

	*********************************************************************************************************
	*********************************************************************************************************
	*********************************************************************************************************
	
	/////////////////////////////////
	Design/Impl Cycles: for this app:
	/////////////////////////////////
	
		UI Stabilization Parts...
			==>Confidence about UI stabilization
			==>Remove / minimize any difficulties or roadblockers of UI design and display
			==>Ease the subsequent component functionality processes as well
			
			Good:
				How to use mock data to do some good UI
				How to add mock data...: mock data are not just for testing, also for UI...
				How ...
			
			UI Design:
				Data Enabled UI Design
				Business Flows
				
			Summaries:
			
				==>Step 1:	Choose a layout
					==>Header + SideNav + Main-Contents:
						==>
						==>Method 2:	Utilize router module + components
						==>
					==>...
					==>...
			
				==>Step 2:	Design a layout:
					Page Layout Design: Many Layouts and UI insights and practices
					
					==>MD:
						==>
						
					==>Bootstrap4:
						==>For layout: 	mainly: Bootstrap Grid Systems:
										==>Point 1: This is the core part from BT for layout: because of it, 
													so many developers use it because they have read this principle
										==>Point 2: It is pinned for: Mobile-first + RWD: pure responsive design: which is also one of the "Grid" meanings
										==>Point 3: Why do developers always try to use this like col-*-*? ==>because it is always better to use RWD like Grid
													==>Similar to: Angular always Ajax calls with HttpClient...
										==>Point 4: 1) Way 1: col-*-* 2) Way 2: auto-layout by BT default - based on how many columns to percentagized
										==>
					...
				==>Step 3:	Section Design:
	
					==>MD: Containers
	
						==>
						<mat-drawer-container>
							<mat-drawer-contents>
							<mat-drawer>
							<mat-drawer>
						
						
						
				
					==>BS4:	Containers
					
						==>
				
				
				==>Step 4:	Sub-Section Design:
				
					==>Tabs:
						<mat-card>
						<mat-card>
					
					==>
					
				==>Step 5:	Enable Smoothies between Sub-Sections:
				
				
				
				==>Step 6:	Feature-based Design:
					
					==>Buttons:
						HTML:
							==><input>
							==><button>	https://www.tutorialrepublic.com/html-reference/html-button-tag.php
						BT4:
							==>Most of the BT4: class styling...
						MD
				
					==>Modals:
						==>MD Way: there are a couple of variations
							==>
						==>BT4 Way:
							==>Way 1: Bootstrap native ways: Modal.js:
								Utilize its own Collapse.js and button and related attributes data-* to implement modal by BT4 way
							==>Way 2: ngx-bootstrap:
								==>https://valor-software.com/ngx-bootstrap/#/modals
								
								==>Way 2:	Good-over-night work strategy 1:
												Keypoints: 1) Enable 3+ hour sleep 2) No coffee before this 3+ sleep time 3) Use alarms 4) Add coffee after this 3+ sleep time
											==>start working at 6pm
											==>not drinking coffee at all
											==>9pm/10am: you are real tired: then immediately go to sleep: for 3 hours: how to wake up? - alarms wake you up...
											==>Around: 2/3am: Continue: drinking "coffee" with no medicines added
											==>8am: drink another cup of coffee to start good second day schedules
								
							==>Way 3: ng-bootstrap?
							==>...
						==>Mozilla Way (MDN/Firefox): https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog
						
						==>HTML/CSS/JS Way: native ways
							https://www.w3schools.com/howto/howto_css_modals.asp:
								==>Point 1: native HTML way (all or many frmwk are wrappers on this...)
								==>Point 2: how to stick out:
											1) JS: Events: action on button: use common HTML's events to add actions to button, etc.
											2) JS: "block/none": appear/disappear
											3) CSS: When "block": z-index + div ==>Sit on top of the main page: popup
								==>Point 3: Steps:
											1) Step 1: write HTML
											2) Step 2: 
								==>
							
					==>Dialogs
					
					==>Misc:
						Custom Modal Window / Dialog Box:
							https://jasonwatmore.com/post/2019/04/16/angular-7-custom-modal-window-dialog-box
					
			
			
			UI Parts: more complicated and advanced than DMT app
				==>Landing Page:
					Angular UI router enabled =>Home Component
				==>Home Component:
					==>html: use: standardized-3-Section design: Header + Side-Nav + Main-Contents

				==>Section-1: Header Section:
							  ==>Component: "app-header"
							  ==>Can enable multiple sub-sections
							  ==>This MissionMap: enable 3 sub-sections:
									1) Main banner and logo section
									2) Main header-menu section:
										==>Menu links: environment settings
										==>Data Items: from JSON data for the app
										==>
									3) AlertMessage section:
										==>Use: global service: NotificationService - with this component: notify and display alert messages
										==>Use: MD's MatSnackBar to enable notification service and displays:
												The alerts message section should be toggled: so using this snackbar is good
										==>Use: Design 3 templates and snackbars: main, info, and error
										==>UI: use <ng-template> to design this message section
										==>
							  
				==>Section-2: Side-Nav:
				
					==>Side Menu Contents 1: DTS Layer: "Duty to Serve Layers"
											 ==>Component: "app-dts-layer"
				
					==>Side Menu Contents 2: Search Areas Data/List/Checkboxes: "Other Geographic Layers"
											 ==>Component: "app-geographic-areas"
					
					==>Side Menu Contents 3: Search Property:	With "Search" functionality: go to "property search results" on the right side sub-section
											 ==>Component: "app-propertysearch"
				
				==>Section-3: Main Contents:
					==>Use MD's drawer container: enable 2 sub-sections: mat-drawe-container <= "sidenav" category
						https://v8.material.angular.io/components/sidenav/api
						==>Sub-Section-1: Google Map API map section
							==>Designed by: mat-drawer-contents:
								==>Enabled: "Search-Address" functionality
								==>Google-Search: Component <"app-search">
								
								==>Map Contents: 
								
						==>Sub-Section-2: Right side results section
							==>Designed by: mat-drawer
							==>Enabled: Component <"app-results">
								==>2 tabs: mat-tab-group / 2 mat-tab sections
								==>Each sub-folder: sub-feature: the results from the 3 main functional services
								==>Each Tab Section:
									==>1) ng-template
									==>2) Component: "app-xxx-results"
													  ==>Quick Start Results: 
														 ==>mat-card
														 ==>mat-card-content
													  ==>property search results:
													  ==>address search results:
													  ==>Selected Results: For functionality: "Selected Point Feature"
															==>This feature: help the usage with "selecting point(s) on map"
															==>UI: mat-card selector sections
															==>
				
					==>To Do: check those containers and contents and drawers with data display and processing
					
	
	/////////////////////////////////
	Functional Flows: for this app:
	/////////////////////////////////
		
			not: page flows
			not: call flows: Java... 
			not: module flows or ...
			not: data flows...
		
		
			==>Core Services:
				==>App"Level"Service:
					Means: Application-Level services
					==>Glue various components
					==>Conduct application-specific and scoped services and data processing
					==>
					
					
	/////////////////////////////////
	Build and Deployment:
	/////////////////////////////////	
	
	ng serve: works
	ng build: works
	ng build --c=production
	ng build --prod="true"
	
	
	*********************************************************************************************************
	*********************************************************************************************************
	*********************************************************************************************************
		
	==>HttpClient: Integration with RESTful API Apps:

		==>All Calls:	Ajax calls: this is from common Angular Design Considerations:
						==>1) There is no need to do regular page refresh calls for Angular apps
						==>2) Angular is a JS app: JS apps tend to use Ajax: jQuery ajax... ==>Because JS code is so easy to do Ajax compared with JSP/...
						==>3) XHR is originated from JS...

		==>Method 1:	HttpClient APIs: same thing as: Observable.subscribe()
						==>HTTP GET Request Examples
							https://jasonwatmore.com/post/2019/09/06/angular-http-get-request-examples
							https://www.techiediaries.com/angular/angular-8-7-tutorial-example-rest-api-httpclient-get-ngfor/
						==>HTTP POST Request Examples
							https://jasonwatmore.com/post/2019/11/21/angular-http-post-request-examples
						==>JSONP:
							https://en.wikipedia.org/wiki/JSONP
						==>RESTful Integrations:
							https://vocon-it.com/2017/06/24/consuming-a-restful-web-service-with-angular/
							https://github.com/oveits/consuming-a-restful-web-service-with-angular-vi
							https://www.positronx.io/angular-7-httpclient-http-service/
							
		==>Method 2:	Promise:
							https://codesource.io/using-promises-to-make-http-requests-in-angular/
							https://dzone.com/articles/angular-observables-and-promises-how-to-use-them
		
		==>Method 3:	Subject? / RxJS?
		
		==>
	
		======>Angular Official Documentation Summaries: HttpClient
			==>Setup:
				==>Concepts:
					==>
					==>HttpClient Calls: the subscribe(): no call backs ==>With arguments: those are callbacks
						==>Always subscribe() for all API calls: even Delete call
					==>HttpClient Calls: APIs: can return a req: then multiple subscribes can be called on the req
				==>Options: 6 types: each type can enable some sub-features of the HttpClient calls
							==>These 6 types: use string unions instead of plain strings
								==>AKA: the HttpClient calls expect: actual listed string types - not the generic "string" type
							==>1) When the options are added to the call's arguments directly, it is ok
							==>2) When the options are added to a const options variable, which is then passed to the call as argument:
								  1) The generic "string" type is in use, which is incorrect
								  2) The solution is: 'text' as const: so the specific 'text' string data type is in use
							==>3) HttpHeaders: new or set
							==>4) URL Parameters: new or set
				==>Use: interface to handle the returned response: because the response is a place object, which cannot be converted into one class
						==>So subcribe() call convert the plain object response (interface type) into fields assigned to results in component
				==>Use: "Typed Response object":
						get<call type parameter>
						==>Mostly an interface: ==>Then can utilize RxJS's operator features to process the data:
							==>1) map
							==>2) Async Pipe
						==>AKA: typed-data-object: e.g.: an interface object ==>Then easier to consume
							==>Scenario 1: if typed as an interface: then access like data['field']
							==>Scenario 2: if not typed - it is an Object: then access like (data as any).field
				==>Use: Full Response:
						==>This is one of the above 6 options
						==>If typed response type is specified like get<Config>: it means: the Response's body is Config
			==>Request Types:
				Get
				Post
				Delete
				Put
				...
				Jsonp:
					==>Can be used when CORS is enabled, so across-domain requests can use JSONP to do calls
			
			==>Data Handling:
			
				==>
			
			
			==>Handle Request Errors:
				HttpClient Way: use RxJS (this is normal: Observable is from RxJS)
					=======>Able to quickly check RxJS APIs and fields
					http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html
					https://devdocs.io/rxjs/					
					==>HttpErrorResponse: ==>have an "error" object: encapsulate 2 types of errors:
						1) Non-server error:	JS: eventError: network/client-side/etc.
						2) Server error:		server response code: 404/500/etc.
					==>HttpClient:			==>Can handle them + log them + return an ErrorObservable for further processing (like pipe(): retry / catchError)
					==>RxJS: provider many operators: are operators the same or similar to methods? YES
						==>catchError()
						==>retry: such as: due to mobile calls...
						==>...
					==>Because Observable is from RxJS, so we use RxJS operators to do this handling
						==>operator/method can be called with the name if zero-argument or common arguments?
							==>Such as: this.handleError ==> instead of this.handleError(...)
						==>
					
			
				Observable?
					==>
				Promise: resolve/reject
			
			==>Modifications:
				==>Headers
				==>Parameters
			
			==>Utilize Interceptors:
				==>Interceptors: simplify/replace the components' tasks: same interceptor(s) can be used for both request and response
				==>API 1: Implement HttpInterceptor interface: intercept()
				==>API 2: HttpHandler: the handle() API processing
				==>Request Chains of Interceptors: reversed order of response chains of interceptors
				==>Provides: AppModule: set up a barrel: gather all interceptors and add as a const variable
				==>Provide in the same injectors as the HttpClient: root or the module/component level
				==>Usage: Modify the request body + clone()
				==>Usage: Add default headers for the request
				==>Usage: Add authentication token (such as: from cookies) and add to the token to the subsequent outgoing request
				==>Usage: Logging: use pipe/tap with next() to add extended logging to the response Observable
				==>Usage: Caching: 1) Interrupt some normal flows and delegate to some caching interceptors for some requests
				==>Usage: Emits multiple values: x-refresh: can check 
				==>
				
				Advanced and complicated applications may use the interceptors
				==>But it can simplify some components' work and methods and tasks
				
			==>Advanced Features:
			
				==>RxJS operators
				==>Subject
			
				Those features:
					==>1) Come from the 6 types of the HttpClient call's options arrays
					==>2) Come from other call needs - including RxJS operators features and user event features
			
				==>Typed response:
					==>Same as the above "typed-Data-Object"
				
				==>Return full response:
					==>Same as the above "full response"
				
				==>report progress feature
			
				==>RxJS: debouncing
						==>1) HTML: keyup event: send each user typed event to component's method call
						==>2) Component method: call RxJS's 3 operators:
								1) debouncing(500): 0.5 sec ==>If user has no input for 0.5 sec ==>We can extend this
								2) wait for value changed
								3) switchMap(): call backend search service: 
				
				==>XSRF Protection: see other App Security section
	
			==>Testing HTTP Requests: HttpClientTestingModule			
	
		Topic: SetUp - BaseUrl:
			==>Angular use: <base="/"> to remove the need of the root url part
			==>By environment:
				providers: [
					{ provide: "BASE_API_URL", useValue: environment.apiUrl }
				]
				export const environment = {
				  production: false,
				  apiUrl: "..."
				}; 
			==>@Inject BASE_URL from <base="/">
				  main.ts:
						export function getBaseUrl() {
						  return document.getElementsByTagName('base')[0].href;
						}
						const providers = [
						  { provide: 'BASE_URL', useFactory: getBaseUrl, deps: [] }
						];					
				  component.ts:
				  constructor(http: HttpClient, @Inject('BASE_URL') baseUrl: string) {
					http.get<WeatherForecast[]>(baseUrl + 'api/SampleData/WeatherForecasts').subscribe(result => {
					  this.forecasts = result;
					}, error => console.error(error));
				  }
			==>Get from parent class:
				export class BackendBaseService {
				  baseURL: string = 'http://localhost:8080/myApp';
				  constructor(){}
				}			
				@Injectable()
				export class ItemsService extends BackendBaseService{
				  constructor(private http: HttpClient){  
					super();
				  }
				  public listAll(): Observable<any>{    
					return this.http.get(`${this.baseURL}/api/items`);
				  }
				}				
			==>Customized HttpClient:
				@Injectable()
				export class ApiHttpClient extends HttpClient {
				  public baseUrl: string;
				  public constructor(handler: HttpHandler) {
					super(handler);
					// Get base url from wherever you like, or provision ApiHttpClient in your AppComponent or some other high level
					// component and set the baseUrl there.
					this.baseUrl = '/api/';
				  }
				  public get(url: string, options?: Object): Observable<any> {
					url = this.baseUrl + url;
					return super.get(url, options);
				  }
				}			
			==>Interceptor:
				providers: [
					{ provide: "BASE_API_URL", useValue: environment.apiUrl }
				]			
				@Injectable()
				export class BaseUrlInterceptor implements HttpInterceptor {
					constructor(
						@Inject('BASE_API_URL') private baseUrl: string) {
					}
					intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
						const apiReq = request.clone({ url: `${this.baseUrl}/${request.url}` });
						return next.handle(apiReq);
					}
				}	
			==>Use: Create a proper injectable that implements HttpInterceptor
				providers: [{
					  provide: HTTP_INTERCEPTORS,
					  useClass: APIInterceptor,
					  multi: true,
					}
				  ]
				import {Injectable} from '@angular/core';
				import {HttpEvent, HttpInterceptor, HttpHandler, HttpRequest} from '@angular/common/http';
				import {Observable} from 'rxjs/Observable';

				@Injectable()
				export class APIInterceptor implements HttpInterceptor {
				  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
					const apiReq = req.clone({ url: `your-api-url/${req.url}` });
					return next.handle(apiReq);
				  }
				}		
			==>extends BaseRequestOptions
			
			==>extends RequestOptions
			
				https://stackoverflow.com/questions/34516651/set-base-url-for-angular-2-http-requests/50387785
				
			
		Topic: SetUp - Mock/Test Data
			==>Method 1:	return this.http.get('assets/testdata.json');
		
		
			==>Method 3:	Mock Backend Example for Backendless Development
							https://jasonwatmore.com/post/2019/05/02/angular-7-mock-backend-example-for-backendless-development
		
		Topic: Direct Work on Observable: but if only working on HttpClient APIs, then no need
			==>Imports:
				import { Observable, throwError } from 'rxjs';
				import { catchError, retry } from 'rxjs/operators';			
				==>Observable: Manipulate or operate on Observable: then add RxJS
				==>Observable: apply RxJS operators to an Observable to get a new tailored stream
			==>
		
		Topic: Utilize jQuery
			import * as $ from 'jquery';
			$.ajax({
				url: 'http://www.webservicex.net/globalweather.asmx?op=GetCitiesByCountry',
				data: { CountryName: 'Spain' },
				success: (data) => {
					console.log('Hey, we got a success response', data);
				},
				error: (err) => {
					console.error('We got an error :(', err);
				}
			});	
			==>Don't use jQuery, Angular provides you with everything you need out of the box and it's faster and usually more powerful too
	
	==>HttpClient: Integration with SOAP API Apps:
	
		Summaries:
			==>Angular SOAP integration solutions: more like: SOAPUI/Postman/Curl solutions instead of "Java JXB solutions"
			==>They pass in: xml request and returned as: xml response: similar to SOAPUI...
	
		==>Method 1:
			There is a way to consume SOAP services in Angular; no third party packages or libraries required. In a nutshell, you set the response type as text, construct an XML document out of the XML text, and (if desired) parse the XML document into JSON format
			https://stackblitz.com/edit/angular-soap-test?file=src%2Fapp%2Fsoap.service.ts
			
			import { HttpClient } from '@angular/common/http';
			import { map } from 'rxjs/operators';
		
		==>Method 2:
			import {Page, Alert, NavController} from 'ionic/ionic';
			import {Http} from 'angular2/http';
	
		==>Method 3:
		
		
		
		==>Advanced Usage:
		
			==>Asyn Impl:
				One way to program asynchronously is to use callbacks
		
			==>JSONP:
				https://codecraft.tv/courses/angular/http/jsonp-with-observables/
				==>Why JSONP?
				1) CORS
				2) The endpoint API must support JSONP callback
				3) The resource API returns the JSON response wrapped in a callback function
				4) GET only
				
				
			
			==>Promise:
				API: ES6 APIs
				DOC:	https://codecraft.tv/courses/angular/es6-typescript/promises/
				Editors/Runner:
					https://plnkr.co/
					https://stackblitz.com/angular/ldbamexeojd?file=src%2Fapp%2Frequest-cache.service.ts
				
				Promise: a kind of special callback... 
					=> intead of a generic callback function... 
					(It serves the same function as callbacks but has a nicer syntax and makes it easier to handle errors)
					+ ...
					==>var promise = new Promise((resolve, reject) => {});
				Observable: apply RxJS operators to an Observable to get a new tailored stream + handle errors
					http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html
					https://devdocs.io/rxjs/
				Subject: implements Observer interface + a Subject has state, it keeps a list of observers + it is an Observable
				
				Observable:
					Observable is just a function that takes an observer and returns a function Observer: an object with next, error.
					Observer allows to subscribe/unsubscribe to its data stream, emit next value to the observer, notify the observer about errors and inform the observer about the stream completion
					Observer provides a function to handle next value,errors and end of stream(ui events,http responses,data with web sockets).
					Works with multiple values over time
					It is cancel-able/retry-able and supports operators such as map,filter,reduce etc.
					Creating an Observable can be -Observable.create() - returns Observable that can invoke methods on -Observer  Observable.from() - converts an array or iterable into -Observable  Observable.fromEvent() - converts an event into Observable -Observable.fromPromise() - converts a Promise into Observable -Observable.range() - returns a sequence of integers in the speciï¬ed range
				Promise:
					A promise represents a task that will finish in the future;
					Promises become resolved by a value;
					Promises get rejected by exceptions;
					Not cancellable and it returns a single value
					A promise expose a function (then)
					-then returns a new promise;
					-allows for the attachment of that will be executed based on state;
					-handlers are guaranteed to execute in order attached;
	
				//
				//Maintain states
				//Always async
				var promise = new Promise((resolve, reject) => {
				  // do something once, possibly async
				  // code inside the Promise constructor callback is getting executed synchronously

				  if (/* everything turned out fine */) {
					resolve("Stuff worked!");
				  }
				  else {
					reject(Error("It broke"));
				  }
				});

				//after the promise is resolved or rejected we can call .then or .catch method on it

				promise.then((val) => console.log(val))      // logs the resolve argument
					   .catch((val) => console.log(val));    // logs the reject argument
					   
				==>var promise = new Promise((resolve, reject) => {};	==>LambaExpr / Arrow-Function
					==>Callback function:
						function(resolve, reject){ //do something }	
							(resolve, reject) => {}
						function(){ xxx }	
							() => {}
				API: new / resolve() / then/catch / val/error
				
					var promise = new Promise((resolve, reject) => {reject('Promise Rejected')});
					var promise = new Promise(function(resolve, reject) => {reject('Promise Rejected')});
					promise.then((data OR: data: any)=>{}).catch((error)=>{});
					promise.then(function(data)=>{}).catch(function(error)=>{});
					promise.then((data)=>{},(error)=>{});
					promise.then(data=>{},error=>{});
					promise.then(function(data)=>{},function(error)=>{});
					promise.then(data=>{resolve();},error=>{reject();});
					promise.then(data=>{resolve(data);},error=>{reject(error);});
					==>Similar to JDK8's functional interface: ...
					
					Pending: Initial state, neither fulfilled nor rejected
					Fulfilled: onFulfilled() will be invoked, corresponds to resolve()
					Rejected: onRejected() will be invoked, corresponds to reject()
	
			==>Observable into Promise:
				Service APIs -> Observable -> Promise
					const promise = this.httpClient.get(this.apiUrl).toPromise();
				Service APIs -> Observable -> Pipe: this is useful: further process the observable
				
			==>Generations and Conversions:
				Observable:
					==>HttpClient APIs all return Observable
					==>Use: generator ways: API: of(), ...
					==>
					
				Promise
					==>new
					==>toPromise()
					==>
				
				Subject:
					==>?
				
			==>Observables and Promises:
				==>Many times as a returned value for other routines and logic to use
				
				console.log(promise); 

	==>Tiered-Services:
	
		==>Intermediate Services:
			==>Interact with raw service tier to parse the raw data more into other domain objects and forms

	   
	==>Misc:
		Topic: Ionic (mobile app framework): use Angular
		

==>Step 9:	Shared Modules
	==>

	==>Shared Services: using RxJS: Subjects, etc.

	==>App-Core: add app model classes:				Assigned to Rubi
	==>App-Core: add app util classes (pipe):		Assigned to Jerry



========================================================================================================================
========================================================================================================================
========================================================================================================================


