
===========================================
SQL Scenarios:

==>DDL:
	Create table ...
==>DCL:
	Grant privileges to DB groups, users, 
	Accesses privileges
==>DML: CRUD

===========================================
DML-SQL Methods 1: Common/Basic

CRUD:
	SELECT:
		select * from table1 where ...
		select * from table1, table 2 where ...
			==>largest scope of joins: cross join | cartesian join		
				Cross-join is SQL 99 join and Cartesian product is Oracle Proprietary join
				Cartesian product result-set contains the number of rows in the first table, multiplied by the number of rows in second table	
			==>outer join / inner join: needs ON clause to map two columns of tables:
				==>Full outer joins: left outer join and right outer join
					==>Left outer join: right side table's special data applied to all of the left side table
						==>Left side table: not matched with the conditions: but still included
					==>...
				==>inner joins (based on on-conditions)
					==>Without on-conditions:
						1) natural join: based on default common names of columns
						...
					==>inner join: exact match from both table by conditions
					
		select * from table1 t1 join tables t2 on t1.col1 = t2.col2 where ...
	INSERT
		insert values
		insert select
	UPDATE
	DELETE

===========================================
DML-SQL Methods 2: Intermediate

==>Variations:
	Use: as
	Use: single quotes
	Use: underscores
	
==>Case:
	Expression
	Column
	
	case 
		when ... then ...
		when ... then ...
		else ... end
	(case 
		when ... then ...
		when ... then ...
		else ... end) as caseColName
		
		


==>Usage:
	==>Conditional Inserts/Updates:
		==>not exists
		==>exists
		==>Example 1: conditional inserts
			INSERT INTO table1(col1, col2, ...)
			SELECT val1, val2, ... (mostly should not use: from table2: this could select all related rows in tables and insert into table1)
					(val1/val2: could be: multiple forms:
						id_key_column=(select max(id_key_column)+1 from table1):
							==>Use Cases: 1) this column is primary key 2) cannot be NULL 3) But it is not auto-incremented by ORM or DB
							   (Some tables' primary key column is auto-incremented by ORM or DB, and cannot be assigned like this)
						current_timestamp
						CAST(GETDATE() AS DATE)
						date column: can be a string value for the column value here: '...'
						'a string value': 'name'
						an integer: 1000
						a double value: 300.00
						a select clause: this is very useful
							1) PRO 1: It can avoid any joins to get this value: joins are very expensive =>Using this way: just a simple select
								val5=(select col1 from table3 where ...)
							2) ...
						...
				WHERE table2.col1='col1'
					  and not exists (select table1.col1 from table1, table2 where table1.col1 = table2.col1 and table2.col2='name2')
					  ==>Only insert when the condition is true: table1 doesn't have a row with col1 with these conditions: mostly the primary key col1
		==>Example 2: 

==>Usage: IN | NOT IN
	==>Guideline 1: used for multiple values returned
		(otherwise: can use: "=")
	
	UPDATE table set col1=val1, col2-val2, ...
	WHERE col3 IN (select ...)

	UPDATE table set col1=val1, col2-val2, ...
	WHERE col3 = (select ...)
	
==>Usage:
	==>Table Design:
		==>Add: id_created, id_lst_updated, dttm_created, dttm_lst_updated

==>Usage:
	==>Common Errors to Avoid:
	1) NULL:
		==>WHERE clause: where col1 is NULL (is not NULL)
		==>UPDATE Clause: Update table set col1 = NULL where...
		==>INSERT Clause: INSERT INTO table(...) values(NULL, ...)
		==>INSERT Clause: INSERT INTO table(...) SELECT ..., NULL, ...
	2) 

==>Usage:
	==>use aggregate functions and column names together:
		==>The column names: need to be in the "group by" statement:
			1) Aggregate functions: operate on a collection of tupled/rows ==>How come one row's data can be selected together:
				==>Unless this aggregate function value is listed in each of the rows select repeatedly, but not so reasonable
				==>So using aggregate function, the column names need to be in "Group By" clause
				==>aggregate functions operate on the group-by columns
				==>without group-by clause, aggregate functions operate on all rows based on the condition clauses
	
	==>

==>Usage:
	==>Player Concepts: Players can be a table, a sub-query, ..., ...

	==>Joins:
		==>Players:
			==>1) Tables
			==>2) SubQuery or man-made query data sets - function as a table
							  ==>This is good for some  difficult-to-join or standalone data sets, or aggregate function generated data sets to participate into the current join
							  ==>This can enable any tables and any datasets to be added to the join clauses
===========================================
DML-SQL Methods 3: Advanced/Expert

==>example: case

==>example: tokens, declare, ...

===========================================
DML-SQL Methods 4: Master


===========================================
===========================================
===========================================
===========================================
===========================================
===========================================
===========================================
===========================================
Topic: Upsert:

==>Upload + Insert

==>Java


==>SQL:
	==>Use: exists
			not exists

	==>Examples:
	
		TBD
		
		
===========================================
SQL:

==>INSERT:
	==>conditional inserts



===========================================
===========================================
===========================================
Topic: FM:

==>Solution Analysis:
	==>DCR
	==>DCU:
		1) AutoSys Jobs:
			==>Run .sql files: a list of queries
		2) AutoSys Jobs:
			==>Run more than sql files: also run Java logic
	==>Java Programs
	==>Combined Solutions

SQL: DCU:
	==>Scenario: Upsert:
		==>Method 1:
			==>Add both insert and update SQL: ==>one of them: runs and succeeds + another one: runs and does nothing
				1) INSERT:
					==>Topic 1: SELECT clause: ==>If empty: does it mean the INSERT does nothing?
								==>insert into table (..., ...) select a, b from table2;
					==>
				2) UPLOAD:
					==>where clause: easy to set
		==>Method 2:
			==>Use conditional: select, tokens, etc.
	==>Scenario: Large sizes of data rows:
			400 rows
			4000 rows
			...
	==>Scenario:	Why production DB?
					Why does production systems have this main data issues?
						Solutions:
						==>ETL
						==>Database refresh
						==>DBA solutions
						==>

===========================================
===========================================
===========================================
Examples:

Insert into #123(columns1,2....
Select field1= @date, field2 = 1, field3 =2, Courier, field4 =4, .....

case when Customer in (12345,2345,12323) then Courier = 1 else Courier = 2 end Courier

Select field1= @date, field2 = 1, field3 =2, case when Customer in (12345,2345,12323) then Courier = 1 else Courier = 2 end Courier , field4 =4, .....

Select 
	field1= @date, 
	field2 = 1, 
	field3 = 2, 
	Courier = 
		case 
			when Customer in (12345,2345,12323) 
				then 1 
			else 
				2 
		end, 
	field4 = 4, 
	.....

INSERT INTO <table> (<columns>)
SELECT <columns>
FROM <table>
WHERE <condition>;

INSERT INTO Persons (FirstName, LastName)
SELECT *
FROM #tmp t
WHERE NOT EXISTS (SELECT * FROM Persons where FirstName=t.FirstName and LastName=t.LastName)

===========================================
Examples:

MSSQL:
	https://www.sqlservertutorial.net/sql-server-system-functions/convert-string-to-datetime/
	Convert(varchar(30),'7/7/2011',102)

Sybase as well
	Convert(varchar(30),'7/7/2011',102)


===========================================
===========================================
===========================================

