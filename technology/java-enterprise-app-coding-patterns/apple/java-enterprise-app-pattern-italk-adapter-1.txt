
***********************
Apple: Apps:iTalk-Adapter
***********************

***********************
Apple: Apps:iTalk-Adapter: Tech Stacks
***********************
	
	Apple Products/Systems/Modules/Frameworks/Features	
		Wireless Carrier
		A3
		IVR
		CKit
		Siri
		...

	Google Protocol Buffer
	
	Spring Boot WebFlux/Reactive
	
	Spring Boot WebSocket

	Spring Rest Docs

***********************
Apple: Apps:iTalk-Adapter: App Modules
***********************

Module: Dependencies

***********************
Apple: Apps:iTalk-Adapter: App Modules: Shared
***********************

Module: Shared: (Common)

***********************
Apple: Apps:iTalk-Adapter: App Modules: ASR
***********************

Module: WebSocket: ASR
	Automatic Speech Recognition

***********************
Apple: Apps:iTalk-Adapter: App Modules: TTS
***********************

=>Original Developer(s):
	1) Based on any existing apps inside IVR
	2) Based on common frameworks for chats/message-apps:
		1) WebSocket
			==>Bidirectional
			==>Long-stay sessions: like chat apps
		2) ...
	3) Based on Jetty WebSocket patterns
		==>And he chose an open source / common one - Jetty WebSocket

Design: Examples:
	MessagingServer as the main class application
		==>TTS Spring Boot App: startup: as a MessageServer
		==>Immediately open a channel to Siri: based on application.properties file config
		==>
	MessagingAdapter which will capture event when client open connection, receive data (whether text or binary), 
		close connection, error happen for each client connection
	UserSession interface to track each user’s session
	MessagingLogic where we put messaging logics
	Data models
	Repository which will handle all data related operations	

Module: WebSocket: TTS

	==>Spring Boot Application
		==>Define: StatelessBusinessService:
			1) Enabled as an Apple appeng's A3 token communication service application		
	==>Module/Call/Processing Flows:
		==>Initialization:
			==>Spring Boot starts up
			==>Init: app service manager
				==>Init: A3 Service/Token:
					==>Init: A3 token service manager
					==>ivr-auth:
						==>Utilize scheduler control to start/stop A3 Service
						==>Service: initialize an A3 service provider: Siri
							==>Siri is a registered A3 service provider in A3
							==>Service: IVR-Auth: A3SchedulerService: starts up: "SIRI"
				==>A3 token cache: It can cache A3 token in cache
			==>Load TTS properties: application.properties
				==>Contains various Siri websocket info
		==>Instantiate all beans:
			==>1) InvokeWebSocketServer class
				==>Create a Jetty WebSocket Server: ...start it
			==>2) ...
				
				
		==>WebSocket Server Impl: Jetty: 7990: ==>This Spring Boot application serves as the WebSocket Server
			==>Belongs to: eclipse domain
			==>Part 1: Server:
				org.eclipse.jetty.server.Server
				App: InvokeWebSocketServer
			==>Part 2: MessagingServlet: Utilize Jetty WebSocket Servlet
				org.eclipse.jetty.websocket.servlet.WebSocketServlet
				XXXMessagingServlet extends WebSocketServlet
				App: MessagingRegisterServletTTS
			==>Part 3: MessagingAdapter
				org.eclipse.jetty.websocket.api.WebSocketAdapter
				App: WebSocketHandlerTTS
					==>Handle all those:
					MessagingAdapter which will capture event when client open connection, receive data (whether text or binary), 
						close connection, error happen for each client connection
				==>Main API:
					void	onWebSocketText​(java.lang.String message)
					A WebSocket Text frame was received:
						==>For both client-to-server
						   and server-to-client communication
					==>App:
						==>toClient
						==>toServer
						Handlers
			==>UserSession interface to track each user’s session
			==>MessagingLogic where we put messaging logics
			==>Data models
			==>Repository which will handle all data related operations
		
		==>ProtoBuf Impl/Usage:
			siri/service:
				StreamingResponseHelper.java
				==>
		
		
	==>Features: Sound:
		==>Java JDK APIs
	
	
	==>Feature: Siri:
		Host:Port
		Certificate Path
	
	==>Feature: ProtoBuf:
		ProtoBuf: TTS -> (Service Provider) Siri: Blazer Request
			==>Store Siri Audio files
		ProtoBuf: ASR -> (Service Provider) Siri: Request
			==>Store Siri Audio files
	
***********************
Apple: Apps:iTalk-Adapter: App Modules: RESTful API Service: CKit
***********************

Module: RESTful Service: Ckit

	==>Talk to CKit
	==>
	==>? Still use the same module design as TTS?
		==>ProtoBuf: 
		==>Siri:
			==>Still talk to Siri Stream Services
			==>Still use: ProtoBuf
		==>...
		
	==>MVC / RESTful API:
		/ckit
		==>Post
		

***********************
Modules
***********************

Protocol Buffer: gRPC
	==>Message passing and communications:
		==>Siri Speech packets
	==>Stream Services
	
	==>ProtoBuf APIs:
		==>Google APIs:
			Protocol Buffers (Protobuf) is a method of serializing structured data. ... The method involves an interface description language that describes the structure of some data and a program that generates source code from that description for generating or parsing a stream of bytes that represents the structured data.
			REST specifies a way to interact with resources, but does not require any particular encoding for the resource bodies. If you create a RESTful HTTP-based API and use Protobuf to encode the entity-bodies (the technical term for the payload part of an HTTP request or response), then you are using both REST and Protobuf.
		==>Jerry's Experiences: Trion Worlds project
		==>Code Generations:
			==>Message Files -> Java Code Files:
			1) IDE: Eclipse
			2) Maven Plugin
			3) Google API CLI
			4) 
		https://developers.google.com/protocol-buffers/docs/reference/overview
			https://developers.google.com/protocol-buffers/docs/reference/java
			https://developers.google.com/protocol-buffers/docs/reference/java-generated
		https://developers.google.com/protocol-buffers/docs/downloads
		https://developers.google.com/protocol-buffers/docs/javatutorial
	
***********************
***********************

***********************
TDD/Test Domains:
***********************



***********************
***********************
